[
{
	"uri": "http://localhost:1313/installation-and-setup/",
	"title": "Getting started &amp; Installation",
	"tags": [],
	"description": "",
	"content": "Chapter I Installation \u0026amp; Setup In this chapter we explain to you how to set up the ROS2 environment for understanding the framework and developing code within the project. This is not identical to the setup instructions for the RISE-OS software stack that we will eventually develop, however it\u0026rsquo;s very similar :)\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/defining-the-robot/",
	"title": "Defining a robot",
	"tags": [],
	"description": "",
	"content": "When we talk about robot programming, we should spend a quick minute thinking about what the robot exoskeleton that we use is made of and what parts are inside. THis will allows us to later understand what is going on, when we talk about connecting bus systems to actuators and reading pressure values from sensors.\nWhat are robots made of? In our case, the robot is always the exoskeleton, or at the very least a simulation of the exoskeleton. There are plenty of other robots out there, from specialized industry machinery like pick and place machines tha assemble PCBs, humanoid bipedal walking robot like the famous Boston Dynamics Atlas, Quadrupeds like ANYmal that most resemble dogs or robotic arms with gripper attachments that can help to move small object around in environments designed for humans.\nAt their core, all of these robots have to move around to be useful and to be able to exert force onto objects in their surrounding. The source of this movement is an actuator. Actuators come in many different shapes and sizes, and follow different operational principles as well. Pneumatic actuators are moved by compressed air or other gases displacing components of cylinders. Very similarly, hydraulic actuators move robots by pumping some hydraulic fluid, often an oil, through pipes and valves to reach cylinders. Previously hydraulic actuation was th go-to method for many robots, especially in the humanoid space. FOr example, the original Atlas robot used hydraulic fluids to move it\u0026rsquo;s limbs. More recently though, electromechanical actuation has taken the lead, as electric motors have become smaller and their power density, i.e. the amount of torque they can exert per unit of space/weight, has grown.\nMost robots that are electromechanically actuated use a type of electric motor called a BLDC motor. This motor type has many advantage, especially when applied to the field of robotics - however they have one major flaw: making them turn is not easy! Whereas with a classic DC or AC motor one simply applies a voltage, BLDC motors need a complicated commutation procedure that has to be provided by a special motor controller. These small devices implement the control technology for the individual joints of a robot, like our exoskeleton! In additional to simply controlling the motor, they also contain control loops that make sure that we can give the motor controller a positional value, i.e. some degree value in a rotating actuator, and the motor moves there. The source of this position information is a sensor that we refer to as an encoder. These also come in many different shapes and sizes, if they measure a turn on an axis they are referred to as rotational encoders, if they measure position on a line we call them linear encoder. For measuring the position, several different methods exist, most commonly either an optical or magnetic measurement principle is used.\nThe information, where the motor is required to turn to is provided via a Bus system. Multiple bus systems exist, most commonly we will probably find a variation of CAN however many modern robots use EtherCAT. The bus systems can be understood of a local, specialized network that transfers sensor readings and target information between components of a machine. This is the communication infrastructure that connects the main controller, on which ROS2 will be running, with the individual components of the robot, i.e. the actuators, sensors etc.\n"
},
{
	"uri": "http://localhost:1313/installation-and-setup/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Required knowledge We don\u0026rsquo;t require previous knowledge in robotic programming or ROS1/2 for following along with this course. At the same time, getting up to speed with ROS2 and keeping track with this tutorial is much harder if you don\u0026rsquo;t have at least some of the following prerequisites.\nYou should have basic familiarity with Linux. ROS2 as a framework, and the RISE exoskeleton in particular, run a GNU/Linux distribution as an operating system. We will use a containerization technology (don\u0026rsquo;t worry about what that is, understand it is not a prerequisite!) to abstract that away from you as much as possible, and in many cases there will probably be a way to avoid directly using Linux, however using it and knowing the basic workings makes many things a lot easier!\nYou should feel comfortable using the command line. Developing ROS2 systems happens with (almost) no graphical tools, therefore you should feel comfortable navigating a computer using a Unix like shell. It would be good if you know, for example: how to move between directories, execute and stop programs and processes, install external software packages and use command line interface tools. All tutorials and code examples here assume a bash shell. There is no need to be proficient in shell scripting, know detailed debugging toolchains or go below the level of the shell.\nYou should know some common software development tools, that are used to develop code together in a team and make sure that quality standards are upheld. Especially, you should know the basic principles behind the version control system git. We will use git in combination with the remote source code host \u0026ldquo;GitHub\u0026rdquo;. Ideally you have an idea what add, commit, push, branch, checkout, fetch and pull mean in the command line, and are able to navigate the GitHub web interface to create pull requests, issues and branches. In case you feel unsure about your capabilities here, git is quite easy to learn and can be picked up quickly, see some tutorials here (Guide from RedHat) and here (YouTube).\nAt least basic to good command of one of the two programming languages used in this project: Python and C/C++. Yes, there is technically the option to write ROS2 code in many more than the two languages described here. However, mixing and matching many different languages together makes things generally harder to maintain and harder to understand. Unless there is a very good reason to do so, we will not do so. Therefore you should feel productive in at least one of the two languages. Making practical use of a language in a specific setting is a great opportunity to learn and acquire more proficiency, not starting from zero is important here! Together with the language itself, it\u0026rsquo;s also helpful to have a general understanding of the toolchains associated with each language, as well as the surrounding ecosystem.\nWhile we obviously provide help and support if during the course of the semester you have questions regarding one or more of these topics, knowing and being able to use them to at least some basic, productive degree is your responsibility.\nUseful knowledge The topics described here are \u0026ldquo;nice to have\u0026rdquo; but not required, and it\u0026rsquo;s perfectly fine to start the tutorial without them. Dont feel intimidated if you have never heard of them, they are very much learnable on the go!\nThere are several topics that are very useful to know when developing code for the RISE exoskeleton. These include but are not limited to:\nExpertise with the EtherCAT bus system and communication standard, that we use to make real time control of actuators possible and read back sensor values from different corners of the system. To do this, we use the SOEM driver setup.\nKnowledge of Real time operating systems for x86 architecture platforms. We will have to make some parts of the overall software stack compatible to some real time requirements at some point in the future.\nKnowledge of relevant standards for the development of software for mechatronic systems in the medical device space. We dont aspire to become a medical device anytime soon, but still try to align our development process as best as possible.\nHardware requirements In case of running Linux, we will help with operating system related problems only if you are running a \u0026ldquo;mainstream\u0026rdquo; distribution. This includes Ubuntu, Debian, Fedora or Mint, as well as close derivatives of those. If you happen to have a problem on your custom NixOS installation, if your Gentoo based machine can\u0026rsquo;t compile the code, because you implemented a custom fork of the Kernel, or any similar problem on a more \u0026ldquo;exotic\u0026rdquo; distribution occurs, we assume that you have enough technical proficiency to solve the problem yourself and will not provide help!\nTo follow along with this tutorial as well as the eventual software development there are some hardware requirements regarding your computer. Ideally you have a x86 based system, running either Linux (preferred), MacOS or Windows. Depending on your operating system there are specific requirements that have to be met:\nLinux MacOS Windows 64-bit kernal and a CPU that supports virtualization. Check the documentation fo your CPU manufacturer for details. We require support for KVM, you may have to enable this in your computers BIOS settings. QEMU version 5.2 or later. The latest version should be fine. A distribution that is based on the systemd init system Either the GNOME, MATE or KDE desktop environment At least 4GB of RAM, 8GB is much preferred We make use of containerization technologies, running containers in a nested virtualization scenarios, i.e. running a VM in another VM, might cause problems, therefore it\u0026rsquo;s best to run your operating system natively on your computer.\nThe most current or one of the two previous MacOS release. Currently you are safe with \u0026ldquo;Sequoia\u0026rdquo; and \u0026ldquo;Sonoma\u0026rdquo;. At least 4GB of RAM. If you have a computer with the M1 chipset, make sure that the Rosetta translation layer is turned on by executing the following command in the terminal. softwareupdate --install-rosetta Windows 11 64-bit in either the Enterprise, Pro or Education version 22H2 or higher Windows 10 64-bit with either the Enterprise, Pro or Education Version 22H2 or higher. Having Hyper-V enabled for virtualization. You may also have to enable Virtualization in the terminal Al least 4GB of RAM. Alternatively, if you have WSL enabled:\nWSL version 2.5 or higher Windows 11 64-bit: Home or Pro version 22H2 or higher, or Enterprise or Education version 22H2 or higher. Windows 10 64-bit: Minimum required is Home or Pro 22H2 (build 19045) or higher, or Enterprise or Education 22H2 (build 19045) or higher. The same hardware requirements as above. You also should have an internet connection that allows you to reach GitHubs servers and common package mirrors.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/",
	"title": "Core Concepts of ROS2",
	"tags": [],
	"description": "",
	"content": "Chapter II Core Concepts of ROS2 Here we explain the very core concepts behind ROS2 and how it is used to make robots do interesting things, in a safe way. We will learn about some of the theory behind it and what the key concepts are behind the workings as well as a little bit of history!\n"
},
{
	"uri": "http://localhost:1313/installation-and-setup/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Great! With all formal details out of the way we can start to dive into ROS2. In this tutorial we will first install the framework an then start explaining how it works, to give you the opportunity to try everything on a practical example, while reading or watching the tutorial. Also, as you will notice later on, we will install ROS2 in a way that abstracts most of the \u0026ldquo;technical details\u0026rdquo; away for a later date. So, don\u0026rsquo;t worry about not understanding anything for now, this is just a brief period and we will explain everything in much more detail as soon as we are done here.\nInstalling Docker We will install a ROS2 development environment using the Docker containerization technology. This allows us to not worry about the operating system layer just now, and also standardizes the development environment between team members. Additionally, in case something went majorly wrong, and you want a clean start - no need to setup your computer again, just start a second Docker Container.\nDocker is an open source based technology that sits somewhere in between a virtual machine and a pure application. The virtual machine simulates a complete computer, including (practically) running it\u0026rsquo;s own OS Kernel. A container is basically a virtual machine, just that it doesn\u0026rsquo;t implement all of it\u0026rsquo;s OS features, but uses those of the host system. Therefore a container has most of the features of a virtual machine, but uses less resources at the same time.\nThe docker engine is the part of the program that allows the containers to run on your operating system. Installing this is somewhat easy on Linux, and pretty hard on Windows and MacOS. To make things easier we recommend you to install Docker Desktop, a graphical user interface for interacting with the docker engine, that handily also installs everything for the respective operating system on the host machine. The exact details of how to install this, differ by operating system and are documented on the website of the Docker project. Please follow the instruction there to install Docker Desktop.\nInstall on Linux Install on Windows Install on MacOS You should end up with the Docker Desktop program on your computer, that after starting looks something like this. To get the full DOcker Desktop feature set, getting a Docker account is useful, but there is technically no need to do this.\nGetting the RISE ROS2 Container Now we have to get the container that we want to run using Docker. In our case this includes all parts of the operating system as well as ROS2 pre installed. There are multiple ways on how we can install the container, depending on your operating system or of you prefer a graphical install using the Docker Desktop GUI. See below for a fitting tutorial.\nIf you are on a Linux based operating system, you can install this container using the docker pull command line utility. The same goes for Windows and MacOS using Powershell and the Terminal respectively. It should be installed automatically, as a result of you installing Docker Desktop. If not, go back and check your installation. In case of further problems, a workaround would be the sole installation of the docker CLI and the docker engine, for a tutorial on doing this see here (Linux only).\nTo get the RISE ROS2 container, execute this command ina directory that you deem fitting. Be aware, that this will download around 1.9GB of data:\ndocker pull ghcr.io/riserobotics/rise-docker-ros2-container:main Launching the RISE ROS2 Container You will have to do the following steps every time you shut-down/sleep your computer. If you are unsure if a container is still active, either take a look at the \u0026ldquo;Containers\u0026rdquo; menu in the Docker Desktop GUI in the left sidebar, or execute the following command to stop all images! Be sure that this is what you want to do! docker stop $(docker ps -q). If you want to remove all containers as well, run the same command with rm $(docker ps -aq) attached to the back.\nNow it\u0026rsquo;s time to launch the container we just downloaded. This can be done either via the command line, which is the preferred way, or using the Docker Desktop GUI if you feel more comfortable this way.\nCommand line interface Docker Desktop GUI You can run the pulled image using the following command, executed in the same terminal as where you pulled the image!\ndocker run -d --name rise_container ghcr.io/riserobotics/rise-docker-ros2-container:main The container is now running in the background, and you can jump into it using the following command:\ndocker exec -it rise_container bash Running the container from the DOcker Desktop GUI is quite simple! Navigate to the \u0026ldquo;Images\u0026rdquo; menu in the left sidebar and find the container \u0026ldquo;ghcr.io/riserobotics/rise-docker-docs-container\u0026rdquo;. Use the \u0026ldquo;Play\u0026rdquo; symbol at the end of line to start the container. In the following context menu, simply select \u0026ldquo;Run\u0026rdquo;.\nTo get a terminal on the container, you can either navigate to the \u0026ldquo;Containers\u0026rdquo; menu in the same sidebar and find the one with the matching image name. Then at the very back, you will find three dots that when clicked on provide a context menu that offers the option \u0026ldquo;Open in Terminal\u0026rdquo;. Alternatively you can also use the command line, simply type the following command in any terminal on your computer.\ndocker exec -it rise_container bash Cloning the repository for code examples As addition to this tutorial series, we also provide a set of ROS2 code examples that help to visualize the workings of the framework. These code snippets and notebooks live in a repository here.\nClone these into the container you just installed. To do this, jump into the terminal session that is connected to your container and execute\ngit clone https://github.com/riserobotics/ros2course Installing a code editor You are free to use a different code editor, perhaps you already have your favorite editor installed anyways! However, be warned that we will only provide help if you use VSCode or Vim. If you want to use another editor, it is your responsibility to figure out how to connect containers, and make sure they work robustly.\nIn order to edit code, we want to use a Code Editor. We recommend VSCode if you want to use a graphical editor, or Vim if you prefer the terminal environment.\nInstall VSCode Install Vim VSCode is a graphical editor that is available for many operating systems. You can find the installation instructions for your respective system here:\nLinux MacOS Windows Make sure to perform this install on the host computer, not inside of the container.\nYou will have to use VIm inside of the container that you are running. Luckily it is already installed, so there is no configuration required!\nCongratulations! You have now set up the Docker container that we will use for this tutorial series and the development efforts in the RISE project. Proceed with the next chapter to get started with learning the basics of ROS2!\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/what-is-robot-programming/",
	"title": "What is robot programming?",
	"tags": [],
	"description": "",
	"content": "A little bit of History! ROS stands for Robot Operating System, yet it is not an operating system. Most accurately, we may describe ROS2 as a collection of tools, libraries, middleware and a community of packages that can be used to control some robots. The federated structure, and the modular nature of the system allows users to interchange software packages inbetween projects, and make components reusable.\nTraditionally this was, and still is not always the most straight forward approach. Robots are by nature quite heterogenous machines, in that two robots must not share any two components or even remotely look alike. This makes robot programming hard and equally heterogenous, people and companies usually started by developing robot software specifically tailored to their own needs, which is in many cases the right approach for companies with large R\u0026amp;D budgets and many people involved in development.\nFor academia and startup environments however, this would mean a massive investment of time and resources into the development of boilerplate code to enable robots to do basic tasks, reinventing the wheel many times over with no real gain of performance. For this audience Willow Garage, a startup accelerator for early-stage robotic companies laid the groundwork for what was to become ROS. With the main advantage of making robotic software modular and interchangeable, it applied the principles of open source collaboration to robotic software, reducing startup times for new systems drastically. This obviously results in ROS being able to do essentially everything, with the right combinations of community contributed ROS packages and self written code to combine everything into a working piece of software, but none of it perfectly well.\nStill ROS, and by now ROS2 has become the defacto standard in academia and early stage robotic companies and it enjoys some adoption in industry as well. Especially in the field of robotic arms, where real time requirements are not as hard as with bipedal underactuated system, ROS2 prevails and is the dominant software framework for robotic software development.\nCore principles Robotic software must adapt to the robot that it is applied on. Therefore ROS is set up to mirror the way robots are build, a collection of many individual parts that work together and depend on one another. For example, in a physical robot you might have motor controllers, batteries, a set of motion sensors and a camera. Each one of these components requires some software to control it.\nThe motor controller has to be controlled by the appropriate driver software that allows for communication via the bus system. Additionally we require some control algorithms to enable a simple control strategy that converts position data of the motor to individual commands over some period of time.\nThe batteries requires the same driver, but additionally there may be a load balancing model that has to be computed. Also battery charge estimation is to be performed by using sensor values measured within the battery.\nMotion sensors have to have sensor fusion algorithms applied to itself, to make sure that the values that we measured are robust and correct\nThe camera has to have computer vision techniques used on its images. This way object detection can be implemented, and computer vision models can be applied to the camera feeds for online evaluation of the surroundings of the robot.\nWhen building robotic software, we therefore want to follow this physical principle of modularization. A robot is a collection of different components that are connect together by the means of a communication network, mechanical connections and an electrical distribution network - our robotic software is a collection of different software processes that are connected together using a common communication standard on a communication network.\nNodes and the communication between them We will now apply these concepts to the purpose of robotic software. The equivalent to a mechanical device, like an actuator or joint bearing is called a node. You can think of a node as an individual process that is controlling some thing on your robot. For example, if you have a physical camera mounted to the chassis of a small quadruped, the software controlling the aperture control of that camera would be written as a node. If you have an actuator that is to be controlled using a PID-control loop, the code implementing this PID loop would be written as a node.\nObviously a robot is not just one single camera, or a single actuator. A real robotic system would be comprised of many different nodes, that each serve a very different task. Also, there may be multiple nodes that can be attributed to a common purpose, i.e. there might be a node housing the camera driver and another node housing a computer vision algorithm. Together they allow us to use the hardware capabilities of the physical device in the software system we are building. To order this, ROS allows us to put multiple nodes together into a folder so that they form a package. As there may be many different people using the particular camera, we can share these packages on a packet exchange called rosdep, similarly to how pypi for python packages and apt for debian applications works. We will learn more about this in Chapter V.\nTo make sure that data that is gathered, for example, on the camera is being transmitted to the actuator so that the robot would physically react to an obstacle that is in front of him, ROS2 provides a communication system so that different nodes can communicate with another.\n"
},
{
	"uri": "http://localhost:1313/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "An Introduction to ROS2 Welcome to the RISE \u0026ldquo;An Introduction to ROS2\u0026rdquo; crash course!\nThe goal of this website is to provide notes and references for people interested in developing code within the ROS2 framework for use on the RISE exoskeleton. The world of ROS2 and robotic programming as a whole is quite vast, and this introduction is not attempting to introduce you to every nook and cranny of it. This is - hopefully not literally - a crash course, a set of notes and tasks that will help you get up to speed with writing ROS2 based code.\nThere are several parts of the ROS2 framework that we dont use on the exoskeleton for various reasons. As a result, those will not be covered here, or at most just quickly glossed over. Some parts of the framework are of particular importance, and will therefore be looked on with greater attention to detail. If you want to learn more about the ROS2 framework as a whole, there are lots of resources you can choose from, that take a much more holistic approach to ROS2 and robotic programming.\nWe don\u0026rsquo;t assume any prerequisites in robotic programming, or any of the tools named in this tutorial - even though it certainly helps! This tutorial is structured so that you can skip chapters and parts that deal with information you already know. Every chapter is presented in four different ways:\nThis website combines notes, graphs, images and code snippets. Wherever possible we make references to the code used on the current exoskeleton.\nThe presentation slides avaliable for download on the top of each chapter page. These are the slides used during the introduction workshop at the beginning of each semester.\nThe video recordings of these presentations, as well as some other topics that are worth it to show in greater detail.\nSeveral code examples and notebooks for trying out the content by yourself on your own machine. All of these can be found in this repository.\nAs you will learn, ROS has been under development for a while. Right now, there are many Distributions of ROS that each are named after some species of turtle (Humble Hawksbill, Jazzy Jalisco and so on). However a few years back, the ROS project released a breaking change that remodelled a lot of the underlying architecture, this version is now formally called ROS2 and no longer just ROS, and it\u0026rsquo;s what we are using in this project. For the sake of simplicity we will refer to these ROS2 versions as ROS, but be warned that tutorials from the original ROS, are not fully translatable to how modern ROS(2) works. So, if you are diving deeper into this topic and are trying to find further readings, make sure that the material is about ROS2 (and ideally the two most recent LTS versions \u0026ldquo;Humble\u0026rdquo; and \u0026ldquo;Jazzy\u0026rdquo;) and not the original ROS.\nYou are welcome to only take a look at some of these, or watch all of them. Not for every task in the semester there is a need to know every bit of what\u0026rsquo;s explained in this tutorial, but having a general grasp on how things work is quite useful.\n"
},
{
	"uri": "http://localhost:1313/ros2-ecosystem/",
	"title": "The ROS2 Ecosystem",
	"tags": [],
	"description": "",
	"content": "Chapter V The ROS2 Ecosystem This chapters deals with the ecosystem surrounding RO2.\n"
},
{
	"uri": "http://localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]