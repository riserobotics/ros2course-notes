[
{
	"uri": "http://localhost:1313/installation-and-setup/",
	"title": "Getting started &amp; Installation",
	"tags": [],
	"description": "",
	"content": "Chapter I Installation \u0026amp; Setup In this chapter we explain to you how to set up the ROS2 environment for understanding the framework and developing code within the project. This is not identical to the setup instructions for the RISE-OS software stack that we will eventually develop, however it\u0026rsquo;s very similar :)\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/defining-the-robot/",
	"title": "Defining a robot",
	"tags": [],
	"description": "",
	"content": "When we talk about robot programming, we should spend a quick minute thinking about what the robot exoskeleton that we use is made of and what parts are inside. THis will allows us to later understand what is going on, when we talk about connecting bus systems to actuators and reading pressure values from sensors.\nWhat are robots made of? In our case, the robot is always the exoskeleton, or at the very least a simulation of the exoskeleton. There are plenty of other robots out there, from specialized industry machinery like pick and place machines tha assemble PCBs, humanoid bipedal walking robot like the famous Boston Dynamics Atlas, Quadrupeds like ANYmal that most resemble dogs or robotic arms with gripper attachments that can help to move small object around in environments designed for humans.\nAt their core, all of these robots have to move around to be useful and to be able to exert force onto objects in their surrounding. The source of this movement is an actuator. Actuators come in many different shapes and sizes, and follow different operational principles as well. Pneumatic actuators are moved by compressed air or other gases displacing components of cylinders. Very similarly, hydraulic actuators move robots by pumping some hydraulic fluid, often an oil, through pipes and valves to reach cylinders. Previously hydraulic actuation was th go-to method for many robots, especially in the humanoid space. FOr example, the original Atlas robot used hydraulic fluids to move it\u0026rsquo;s limbs. More recently though, electromechanical actuation has taken the lead, as electric motors have become smaller and their power density, i.e. the amount of torque they can exert per unit of space/weight, has grown.\nMost robots that are electromechanically actuated use a type of electric motor called a BLDC motor. This motor type has many advantage, especially when applied to the field of robotics - however they have one major flaw: making them turn is not easy! Whereas with a classic DC or AC motor one simply applies a voltage, BLDC motors need a complicated commutation procedure that has to be provided by a special motor controller. These small devices implement the control technology for the individual joints of a robot, like our exoskeleton! In additional to simply controlling the motor, they also contain control loops that make sure that we can give the motor controller a positional value, i.e. some degree value in a rotating actuator, and the motor moves there. The source of this position information is a sensor that we refer to as an encoder. These also come in many different shapes and sizes, if they measure a turn on an axis they are referred to as rotational encoders, if they measure position on a line we call them linear encoder. For measuring the position, several different methods exist, most commonly either an optical or magnetic measurement principle is used.\nThe information, where the motor is required to turn to is provided via a Bus system. Multiple bus systems exist, most commonly we will probably find a variation of CAN however many modern robots use EtherCAT. The bus systems can be understood of a local, specialized network that transfers sensor readings and target information between components of a machine. This is the communication infrastructure that connects the main controller, on which ROS2 will be running, with the individual components of the robot, i.e. the actuators, sensors etc.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts-advanced/executors/",
	"title": "Executors",
	"tags": [],
	"description": "",
	"content": "Up until this point, we have not thought more about what actually happens when we call rclpy.spin(node) in our main program. In traditional simple python development, we are usually only aware of programs being executed sequentially, i.e. one bit after the other. As we are building robotic software, this would be unfortunate, as we have software architectures that require many processes to run at the same time and - most importantly, we have to be able to control how and when they run. At this point it makes sense to get to know the different executors that ROS2 offers a bit more.\nWhat is an executor Executors are the components of ROS2 that are responsible for running the nodes that we build. They use one, or if required multiple, threads of the underlying operating system, e.g. mostly Ubuntu, to execute the ROS2 nodes. We can handle this from simple to complicated with a rising degree of control as we get towards the more complicated options.\nFunctions and patterns that are affected by the choice of Executors include Subscriptions to Topics, Timers that lauch reocurring functions, service servers that transmit services and action servers that transmit actions.\nTypes of Executors Be aware that there have been quite substantial changes to the Executors between ROS1 and ROS2. In case you have already gained some experience with ROS1, make sure to study this topic again, as fundamental concepts have changed.\nThe spin executor. This is the simplest executor that is avaliable through ROS2. Here, the node will be executed within the main thread, in practice spin refers to a simple, single threaded executor. In the core of ROS, when the spin executor is called, the middleware is being surveilled for incoming messages and request to the node. These incoming messages are stored within the middleware, it does not matter which one is selected here as all offer support for this behaviour, until the node is scheduled to take over within the main thread. Then the information is retrieved from the middleware and processed. The spin executor is easiest to use, as there are no behaviors that are unintuitive on first view.\nThe SingleThreadedExecutor. This is quite similar in behavior to spin when configured right, but offers more options when it comes to customizability. We will make use of this executor quite often. You can think of the SingleThreadedExecutor as the explicit version of what spin does behind the scenes. Using this executor, you can have more control over when and which nodes are added, when the executor starts and how the shutdown of the nodes is handled.\nThe SingleThreadedExecutor As an example for how the SingleThreadedExecutor and the regular spin differs, see the code examples in ch3-1-executor-comparison. You will find three options that all implement a similar node using a different executor. In spin_one we can observe the simple rclpy.spin() executor, abstracting the complexity of the execution of nodes away from the developer. In comparison to that, check the exec_two_nodes file, where we can see the SingleThreadedExecutor.\nThe MultiThreadedExecutor When we want to enable multi-threaded execution, this is the correct executor to choose.\nUnlike the SingleThreadedExecutor, which processes callbacks sequentially, the MultiThreadedExecutor allows multiple callbacks to run in parallel using different threads. This can significantly improve performance in systems where multiple nodes or callbacks perform blocking operations or long-running computations.\nFor example, a MultiThreadedExecutor is especially useful when:\nYou have multiple subscribers or timers that can operate independently. Some callbacks perform time-consuming tasks that would otherwise block others. You want to make full use of multi-core processors. If we are, for example, building a camera video node that is evaluating each image for potential hurdles, we may want to have two models running at the same time. By default, the MultiThreadedExecutor creates one thread per CPU core, but this can be configured as needed. Developers must, however, ensure that their code is thread-safe, as simultaneous access to shared resources can cause race conditions if not handled properly. We can do this by choosing the usual tools that C++ offers us, when building thread safe architectus (i.e. mutex for example)\n"
},
{
	"uri": "http://localhost:1313/installation-and-setup/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Required knowledge We don\u0026rsquo;t require previous knowledge in robotic programming or ROS1/2 for following along with this course. At the same time, getting up to speed with ROS2 and keeping track with this tutorial is much harder if you don\u0026rsquo;t have at least some of the following prerequisites.\nYou should have basic familiarity with Linux. ROS2 as a framework, and the RISE exoskeleton in particular, run a GNU/Linux distribution as an operating system. We will use a containerization technology (don\u0026rsquo;t worry about what that is, understand it is not a prerequisite!) to abstract that away from you as much as possible, and in many cases there will probably be a way to avoid directly using Linux, however using it and knowing the basic workings makes many things a lot easier!\nYou should feel comfortable using the command line. Developing ROS2 systems happens with (almost) no graphical tools, therefore you should feel comfortable navigating a computer using a Unix like shell. It would be good if you know, for example: how to move between directories, execute and stop programs and processes, install external software packages and use command line interface tools. All tutorials and code examples here assume a bash shell. There is no need to be proficient in shell scripting, know detailed debugging toolchains or go below the level of the shell.\nYou should know some common software development tools, that are used to develop code together in a team and make sure that quality standards are upheld. Especially, you should know the basic principles behind the version control system git. We will use git in combination with the remote source code host \u0026ldquo;GitHub\u0026rdquo;. Ideally you have an idea what add, commit, push, branch, checkout, fetch and pull mean in the command line, and are able to navigate the GitHub web interface to create pull requests, issues and branches. In case you feel unsure about your capabilities here, git is quite easy to learn and can be picked up quickly, see some tutorials here (Guide from RedHat) and here (YouTube).\nAt least basic to good command of one of the two programming languages used in this project: Python and C/C++. Yes, there is technically the option to write ROS2 code in many more than the two languages described here. However, mixing and matching many different languages together makes things generally harder to maintain and harder to understand. Unless there is a very good reason to do so, we will not do so. Therefore you should feel productive in at least one of the two languages. Making practical use of a language in a specific setting is a great opportunity to learn and acquire more proficiency, not starting from zero is important here! Together with the language itself, it\u0026rsquo;s also helpful to have a general understanding of the toolchains associated with each language, as well as the surrounding ecosystem.\nWhile we obviously provide help and support if during the course of the semester you have questions regarding one or more of these topics, knowing and being able to use them to at least some basic, productive degree is your responsibility.\nUseful knowledge The topics described here are \u0026ldquo;nice to have\u0026rdquo; but not required, and it\u0026rsquo;s perfectly fine to start the tutorial without them. Dont feel intimidated if you have never heard of them, they are very much learnable on the go!\nThere are several topics that are very useful to know when developing code for the RISE exoskeleton. These include but are not limited to:\nExpertise with the EtherCAT bus system and communication standard, that we use to make real time control of actuators possible and read back sensor values from different corners of the system. To do this, we use the SOEM driver setup.\nKnowledge of Real time operating systems for x86 architecture platforms. We will have to make some parts of the overall software stack compatible to some real time requirements at some point in the future.\nKnowledge of relevant standards for the development of software for mechatronic systems in the medical device space. We dont aspire to become a medical device anytime soon, but still try to align our development process as best as possible.\nHardware requirements In case of running Linux, we will help with operating system related problems only if you are running a \u0026ldquo;mainstream\u0026rdquo; distribution. This includes Ubuntu, Debian, Fedora or Mint, as well as close derivatives of those. If you happen to have a problem on your custom NixOS installation, if your Gentoo based machine can\u0026rsquo;t compile the code, because you implemented a custom fork of the Kernel, or any similar problem on a more \u0026ldquo;exotic\u0026rdquo; distribution occurs, we assume that you have enough technical proficiency to solve the problem yourself and will not provide help!\nTo follow along with this tutorial as well as the eventual software development there are some hardware requirements regarding your computer. Ideally you have a x86 based system, running either Linux (preferred), MacOS or Windows. Depending on your operating system there are specific requirements that have to be met:\nLinux MacOS Windows 64-bit kernal and a CPU that supports virtualization. Check the documentation fo your CPU manufacturer for details. We require support for KVM, you may have to enable this in your computers BIOS settings. QEMU version 5.2 or later. The latest version should be fine. A distribution that is based on the systemd init system Either the GNOME, MATE or KDE desktop environment At least 4GB of RAM, 8GB is much preferred We make use of containerization technologies, running containers in a nested virtualization scenarios, i.e. running a VM in another VM, might cause problems, therefore it\u0026rsquo;s best to run your operating system natively on your computer.\nThe most current or one of the two previous MacOS release. Currently you are safe with \u0026ldquo;Sequoia\u0026rdquo; and \u0026ldquo;Sonoma\u0026rdquo;. At least 4GB of RAM. If you have a computer with the M1 chipset, make sure that the Rosetta translation layer is turned on by executing the following command in the terminal. softwareupdate --install-rosetta Windows 11 64-bit in either the Enterprise, Pro or Education version 22H2 or higher Windows 10 64-bit with either the Enterprise, Pro or Education Version 22H2 or higher. Having Hyper-V enabled for virtualization. You may also have to enable Virtualization in the terminal Al least 4GB of RAM. Alternatively, if you have WSL enabled:\nWSL version 2.5 or higher Windows 11 64-bit: Home or Pro version 22H2 or higher, or Enterprise or Education version 22H2 or higher. Windows 10 64-bit: Minimum required is Home or Pro 22H2 (build 19045) or higher, or Enterprise or Education 22H2 (build 19045) or higher. The same hardware requirements as above. You also should have an internet connection that allows you to reach GitHubs servers and common package mirrors.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/",
	"title": "Core Concepts of ROS2",
	"tags": [],
	"description": "",
	"content": "Chapter II Core Concepts of ROS2 Here we explain the very core concepts behind ROS2 and how it is used to make robots do interesting things, in a safe way. We will learn about some of the theory behind it and what the key concepts are behind the workings as well as a little bit of history!\n"
},
{
	"uri": "http://localhost:1313/installation-and-setup/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Great! With all formal details out of the way we can start to dive into ROS2. In this tutorial we will first install the framework an then start explaining how it works, to give you the opportunity to try everything on a practical example, while reading or watching the tutorial. Also, as you will notice later on, we will install ROS2 in a way that abstracts most of the \u0026ldquo;technical details\u0026rdquo; away for a later date. So, don\u0026rsquo;t worry about not understanding anything for now, this is just a brief period and we will explain everything in much more detail as soon as we are done here.\nInstalling Docker We will install a ROS2 development environment using the Docker containerization technology. This allows us to not worry about the operating system layer just now, and also standardizes the development environment between team members. Additionally, in case something went majorly wrong, and you want a clean start - no need to setup your computer again, just start a second Docker Container.\nDocker is an open source based technology that sits somewhere in between a virtual machine and a pure application. The virtual machine simulates a complete computer, including (practically) running it\u0026rsquo;s own OS Kernel. A container is basically a virtual machine, just that it doesn\u0026rsquo;t implement all of it\u0026rsquo;s OS features, but uses those of the host system. Therefore a container has most of the features of a virtual machine, but uses less resources at the same time.\nThe docker engine is the part of the program that allows the containers to run on your operating system. Installing this is somewhat easy on Linux, and pretty hard on Windows and MacOS. To make things easier we recommend you to install Docker Desktop, a graphical user interface for interacting with the docker engine, that handily also installs everything for the respective operating system on the host machine. The exact details of how to install this, differ by operating system and are documented on the website of the Docker project. Please follow the instruction there to install Docker Desktop.\nInstall on Linux Install on Windows Install on MacOS You should end up with the Docker Desktop program on your computer, that after starting looks something like this. To get the full DOcker Desktop feature set, getting a Docker account is useful, but there is technically no need to do this.\nGetting the RISE ROS2 Container Now we have to get the container that we want to run using Docker. In our case this includes all parts of the operating system as well as ROS2 pre installed. There are multiple ways on how we can install the container, depending on your operating system or of you prefer a graphical install using the Docker Desktop GUI. See below for a fitting tutorial.\nIf you are on a Linux based operating system, you can install this container using the docker pull command line utility. The same goes for Windows and MacOS using Powershell and the Terminal respectively. It should be installed automatically, as a result of you installing Docker Desktop. If not, go back and check your installation. In case of further problems, a workaround would be the sole installation of the docker CLI and the docker engine, for a tutorial on doing this see here (Linux only).\nTo get the RISE ROS2 container, execute this command ina directory that you deem fitting. Be aware, that this will download around 1.9GB of data:\ndocker pull ghcr.io/riserobotics/rise-docker-ros2-container:main Launching the RISE ROS2 Container You will have to do the following steps every time you shut-down/sleep your computer. If you are unsure if a container is still active, either take a look at the \u0026ldquo;Containers\u0026rdquo; menu in the Docker Desktop GUI in the left sidebar, or execute the following command to stop all images! Be sure that this is what you want to do! docker stop [name of the docker container here]. If you want to remove all containers as well, run the same command with docker rm [name of the docker container here] attached to the back.\nNow it\u0026rsquo;s time to launch the container we just downloaded. This can be done either via the command line, which is the preferred way, or using the Docker Desktop GUI if you feel more comfortable this way.\nCommand line interface Docker Desktop GUI You can run the pulled image using the following command, executed in the same terminal as where you pulled the image!\ndocker run -d --name rise_container ghcr.io/riserobotics/rise-docker-ros2-container:main sleep infinity The container is now running in the background, and you can jump into it using the following command:\ndocker exec -it rise_container bash To get to home type the following:\ncd ~ Running the container from the DOcker Desktop GUI is quite simple! Navigate to the \u0026ldquo;Images\u0026rdquo; menu in the left sidebar and find the container \u0026ldquo;ghcr.io/riserobotics/rise-docker-docs-container\u0026rdquo;. Use the \u0026ldquo;Play\u0026rdquo; symbol at the end of line to start the container. In the following context menu, simply select \u0026ldquo;Run\u0026rdquo;.\nTo get a terminal on the container, you can either navigate to the \u0026ldquo;Containers\u0026rdquo; menu in the same sidebar and find the one with the matching image name. Then at the very back, you will find three dots that when clicked on provide a context menu that offers the option \u0026ldquo;Open in Terminal\u0026rdquo;. Alternatively you can also use the command line, simply type the following command in any terminal on your computer.\ndocker exec -it rise_container bash Installing a code editor You are free to use a different code editor, perhaps you already have your favorite editor installed anyways! However, be warned that we will only provide help if you use VSCode or Vim. If you want to use another editor, it is your responsibility to figure out how to connect containers, and make sure they work robustly.\nIn order to edit code, we want to use a Code Editor. We recommend VSCode if you want to use a graphical editor, or Vim if you prefer the terminal environment.\nInstall VSCode Install Vim VSCode is a graphical editor that is available for many operating systems. You can find the installation instructions for your respective system here:\nLinux MacOS Windows Make sure to perform this install on the host computer, not inside of the container.\nYou will have to use VIm inside of the container that you are running. Luckily it is already installed, so there is no configuration required!\nCongratulations! You have now set up the Docker container that we will use for this tutorial series and the development efforts in the RISE project. Proceed with the next chapter to get started with learning the basics of ROS2!\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/what-is-robot-programming/",
	"title": "What is robot programming?",
	"tags": [],
	"description": "",
	"content": "A little bit of History! ROS stands for Robot Operating System, yet it is not an operating system. Most accurately, we may describe ROS2 as a collection of tools, libraries, middleware and a community of packages that can be used to control some robots. The federated structure, and the modular nature of the system allows users to interchange software packages inbetween projects, and make components reusable.\nTraditionally this was, and still is not always the most straight forward approach. Robots are by nature quite heterogenous machines, in that two robots must not share any two components or even remotely look alike. This makes robot programming hard and equally heterogenous, people and companies usually started by developing robot software specifically tailored to their own needs, which is in many cases the right approach for companies with large R\u0026amp;D budgets and many people involved in development.\nFor academia and startup environments however, this would mean a massive investment of time and resources into the development of boilerplate code to enable robots to do basic tasks, reinventing the wheel many times over with no real gain of performance. For this audience Willow Garage, a startup accelerator for early-stage robotic companies laid the groundwork for what was to become ROS. With the main advantage of making robotic software modular and interchangeable, it applied the principles of open source collaboration to robotic software, reducing startup times for new systems drastically. This obviously results in ROS being able to do essentially everything, with the right combinations of community contributed ROS packages and self written code to combine everything into a working piece of software, but none of it perfectly well.\nStill ROS, and by now ROS2 has become the defacto standard in academia and early stage robotic companies and it enjoys some adoption in industry as well. Especially in the field of robotic arms, where real time requirements are not as hard as with bipedal underactuated system, ROS2 prevails and is the dominant software framework for robotic software development.\nCore principles Robotic software must adapt to the robot that it is applied on. Therefore ROS is set up to mirror the way robots are build, a collection of many individual parts that work together and depend on one another. For example, in a physical robot you might have motor controllers, batteries, a set of motion sensors and a camera. Each one of these components requires some software to control it.\nThe motor controller has to be controlled by the appropriate driver software that allows for communication via the bus system. Additionally we require some control algorithms to enable a simple control strategy that converts position data of the motor to individual commands over some period of time.\nThe batteries requires the same driver, but additionally there may be a load balancing model that has to be computed. Also battery charge estimation is to be performed by using sensor values measured within the battery.\nMotion sensors have to have sensor fusion algorithms applied to itself, to make sure that the values that we measured are robust and correct\nThe camera has to have computer vision techniques used on its images. This way object detection can be implemented, and computer vision models can be applied to the camera feeds for online evaluation of the surroundings of the robot.\nWhen building robotic software, we therefore want to follow this physical principle of modularization. A robot is a collection of different components that are connect together by the means of a communication network, mechanical connections and an electrical distribution network - our robotic software is a collection of different software processes that are connected together using a common communication standard on a communication network.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts-advanced/",
	"title": "Advanced Concepts of ROS2",
	"tags": [],
	"description": "",
	"content": "Chapter III Advanced Concepts of ROS2 This chapter dives deeper into more advanced concepts of ROS2, exploring topics that are not covered in the basic review and only tangentially relevant to the use in the RISE project.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/ros2-packages/",
	"title": "Preparing packages",
	"tags": [],
	"description": "",
	"content": "How ROS2 structures code We will now apply these concepts to the purpose of robotic software. The equivalent to a mechanical device, like an actuator or joint bearing is called a node. You can think of a node as an individual process that is controlling some thing on your robot. For example, if you have a physical camera mounted to the chassis of a small quadruped, the software controlling the aperture control of that camera would be written as a node. If you have an actuator that is to be controlled using a PID-control loop, the code implementing this PID loop would be written as a node.\nObviously a robot is not just one single camera, or a single actuator. A real robotic system would be comprised of many different nodes, that each serve a very different task. Also, there may be multiple nodes that can be attributed to a common purpose, i.e. there might be a node housing the camera driver and another node housing a computer vision algorithm. Together they allow us to use the hardware capabilities of the physical device in the software system we are building. To order this, ROS allows us to put multiple nodes together into a folder so that they form a package. As there may be many different people using the particular camera, we can share these packages on a packet exchange called rosdep, similarly to how pypi for python packages and apt for debian applications works. We will learn more about this in Chapter V.\nWe will now set up a ROS project to demonstrate how nodes and packages can be created an used.\nSetting up the Tutorial environment Make sure that you have the ROS container setup like described in the tutorial on installing the setup. From now on, we assume that you have the Docker container installed and feel comfortable using it. From this point onwards we will also assume that you execute all code within that Docker container and not on the host system. To interact with the container easier, you can open up VScode on the host computer and click on the blue button in the bottom left hand corner. In the resulting drop-down menu, select \u0026ldquo;Attach to a running container\u0026rdquo;. In the following menu select the container you just started. Now, your VScode interface opens up the files in the container, makes the internal terminal run within the container and allows you to execute files in the container.\nDuring this course want to use the git version control system, to track changes and progress, and also allow feedback to be given on your work. Therefore, before cloning the repository, fork it to your own account using the following steps. Go to GitHub and navigate to the repository, which can be found here. On the top right part of the window, you will find the Button \u0026ldquo;Fork\u0026rdquo;. After you press that button, a context menu will open. make sure that the dropdown menu under \u0026ldquo;Owner\u0026rdquo; is set to your private GitHub account, i.e. the account that has your account name not \u0026ldquo;riserobotics\u0026rdquo;. The repository name will be pre set to \u0026ldquo;ros2course\u0026rdquo;, we recommend keeping it this way. The same goes for the description, there is no real need to change it. Before clicking on \u0026ldquo;Create fork\u0026rdquo; make sure to uncheck the checkbox \u0026ldquo;Copy the main branch only\u0026rdquo;, to make sure that all branches of the repository are forked. If you want to learn more about what forking means, see here for some information.\nTo begin, jump into the docker container and open up an internal terminal. Then go ahead and clone the forked repository to the docker container. If you choose your own name for the repository, make sure to adjust the link accordingly.\ngit clone https://github.com/[Insert your GitHub username here]/ros2course Depending on jow you set up your GitHub, you may face difficulty authenticating to the service. If you set up ssh based authentification, either import your keys locally to the Docker container which is not recommended as you may share the container with someone and then unwillingly give them access to your keys, or you mount the key as a local volume and give the container access to said volume. For most people however, you will authenticate with https based procedures. To do this, you can either install the github command line utility gh, or create a token from the Developer settings of your account, as password based authentication has been deprecated. You can find tutorials on token based cloning here, and on setting up the github command line utility here.\nIf you are trying to install gh, know that the Docker container does not have the apt remote repositorie index lists locally, so you will have to run sudo apt update before being able to install anything.\nNow move inside of the cloned repository using the cd tool\ncd ros2course If you type ls to see the contents of the directory, you can see that they are ordered by the different chapters of this tutorial series. As we are in the second chapter, and are working on the first task, move to the directory ch2-1-creating-nodes. Except for a README.md and a subdirectory tests, this should be an empty directory. Here, we want to set up our first ROS project and create some nodes!\nSetting up the ROS2 workspace Every ROS2 project has to run within a ROS2 workspace. At its core the ROS2 workspace is just a folder containing one or more ROS2 packages. Usually we want to create a new folder that will contain this workspace, we are in theory free to choose the name, but it is usually helpful to indicate the purpose of the directory in the name. Create a folder called ros2-node-test-workspace and a folder src within it. Afterwards, move into this folder.\nmkdir -p ros2-node-test-workspace/src cd ros2-node-test-workspace/src The src directory will serve as the home for all our ROS2 packages that we are going to build. Again, in theory we ware not required to put them into the src directory, it is however best practice to do so, making the overall repository structure cleaner and more readable. Up until this point we have not made anything that requires ROS2 yet, all of the tools till now are standard Linux command line tools.\nCreating a ROS2 package Our ROS2 workspace is currently empty, lets change that! We can build a package in two ways, either by putting together the required files in a specific structure ourself, or by using the ros2 command line utility. Here, we will choose the latter option.\nros2 pkg create --build-type ament_python --license Apache-2.0 ros2-sample-package-python This command creates the structure of a minimal implementation of an empty package for us, at the point where we ran the command. We define the license as the Apache-2.0 license, and we name the package ros2-sample-package. Instead of ros2-sample-package we could have also chosen any other name, that is made up of utf8 characters. --build-type defines the build system that we use for this package. We will get into this later in more detail, for now just note that this sets the programming language that you will use in the package. ament_python will result in this being a python package, ament_cmake results in a C/C++ package. We will create both as an example, so also execute:\nros2 pkg create --build-type ament_cmake --license Apache-2.0 ros2-sample-package-cmake To check if everything worked as expected, you can run a test using this command. As an alternative, you can see in the tab menu how the directory structure should look:\nCorrect directory structure at this point . ├── ros2-sample-package-cmake │ ├── include │ │ └── ros2-sample-package-cmake │ └── src ├── ros2-sample-package-python │ ├── resource │ ├── ros2-sample-package-python │ │ └── __pycache__ │ └── test │ └── __pycache__ └── tests └── __pycache__ pytest tests/test_structure_correct.py -v It is important that we should not create packages within other packages, as this will potentially lead to some problems. It is best practice, to make every package at the root of the src directory. See the following for an example of how not to do it.\n. ├── ros2-sample-package-python │ ├── resource │ ├── ros2-sample-package-cmake │ │ ├── include │ │ │ └── ros2-sample-package-cmake │ │ └── src │ ├── ros2-sample-package-python │ │ └── __pycache__ │ └── test │ └── __pycache__ └── tests └── __pycache__ We have now created two ROS2 packages, one of them is called ros2-sample-package-cmake and the other ros2-sample-package-python. Now we will proceed with taking a look at what these packages are composed of.\nPython (ament_python) C/C\u0026#43;\u0026#43; (ament_cmake) Within the folder resources, there is a empty file called exactly like the package it is build in. Even tough this file is empty, it\u0026rsquo;s quite important and cant be deleted! When running, ROS2 needs to check what packages are installed, this file serves as the \u0026ldquo;marker\u0026rdquo; file that ROS2 can search for to see that the package is installed. It\u0026rsquo;s empty, and will almost alwyas stay empty, but it is there for a reason and cant be removed. The folder with the same name as the package contains the __init__.py file, that let\u0026rsquo;s the python interpreter know that this is a package and it can be imported in a different context. This is the place were you will put the python files containing the actual application code. Within test, there are some default test for checking flake8 compatibility, the linter that both we and the ROS2 project uses, as well as for the correct license formatting. You may delete these files, but putting tests in here is generally quite useful. The LICENSE file keeps the LICENSE for the package, that was set when creating it using the ROS2 command line utility. The more interesting content can be found in the three files in the directory, package.xml, setup.cfg and setup.py. These contain the information that is actually relevant to the package and where a lot of the configuration of a package can happen. To understand them, be reminded that packages with ROS are very much meant to be shared across teams, labs and companies. Some of the information that is specified here, is only describing the packge to a registry that other people can then search, if you decide to upload your package.\npackage.xml contains all the information that you can find if you search the ROS2 package registry. The name that is specified here, should be the same as the name of the folder that the whole package is in. Th version can also be defined by the author of the package, same goes for description and the linked email address, used to follow up with the authors in case of problems. More interestingly, the section \u0026ldquo;build_depend\u0026rdquo; declares the dependencys that are required by the project. Be aware that this does not refer to Python packages or C++ header files, this references other ROS2 packages. In the case of our package, as we don\u0026rsquo;t require another ROS2 package as a reference, this is empty for now. \u0026ldquo;test_depend\u0026rdquo; is a similar nominator, for describing the dependency on a standard ROS2 test command, or any other test package that is required for running unit tests used within the package you are describing. A powerful tool is the \u0026ldquo;export\u0026rdquo; keyword, you can use this as a container for exporting additional information, for example which type of build system is to be used. setup.cfg is a quite standard file from the setuptools library that is part of the standard python environment. It serves as a configuration file for the library that describes how python packages should be build, installed and distributed. The reason this is here, is to make sure that when later on you want to start the package, you get to use ros2 run, to launch the package. setup.py is a filename that you perhaps already know if you have engaged with the world of python tooling and library development for a little in the past. This file bundles all information required for building the package automatically, and will be the primary source the ROS2 build tool will get the required structure of your package. On first glance, the ROS2 ament_cmake package seems simpler, as fewer files are present. We can also spot files that were present in the ament_python version of the package, LICENSE for example. While the package.xml file has the same name, and serves the same purpose, it looks a bit different. There is an explicit mention of the buildtool, ament_cmake as well as a different testing scheme, as this is now a C++ package. The directory src will, as is the usual procedure with other C++ projects, contain the header files as well as .cpp files.\nThe only other interesting file is CMakeLists.txt, the file that defines the build procedure for the build tool which is based on Cmake. If skimming through the file, it might seem as if this file in a lot of ways mirrors the same declarations that have already been made in the package.xml file. This is however not (completly) the case. First, a practical reason, parsing CMake script files is quite hard and computationally expensive, as branching and conditional logic are wildly used, therefore they are not ideal for providing structured access to information in a way that e.g. a package manager would need. Second, this being a more technical reason, keeping the build information close to how CMake handles descirptions of build procedures makes interoperability with the rest of the C++ world easier. For more details on how the build system processes these files, see the page on the build system\nWe have now set up a ROS2 package inside the Docker container. Commit your local changes to the repository, to make sure that they can be versioned correctly and referenced by others. If that is completed, move on to the next page, here.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/ros2-nodes/",
	"title": "Creating nodes",
	"tags": [],
	"description": "",
	"content": "Building a ROS2 Node In this part of the tutorial series we want to specify an individual ROS2 node, and get an idea of how it looks like. As most of the functionality of ROS2 is centered around nodes, this tutorial is not encompassing all parts of Nodes. We will not get into executors, launch files and similar topics. These will have to wait until later. For now, the goal is to understand from a high-level perspective how Nodes work, and what you can do with them. Everything that goes on under the hood is a topic for a later chapter of this series.\nThe client libraries When we are talking about ROS2 development, or robotic software development with ROS as a whole, we are usually talking about writing application level code. We are not interested in how ROS2 works itself, instead we rely on the Application Programming Interface (API) that it provides, to interact with what is essentially a black box system to us (Even though we will shed light on the inner workings later in this tutorial series).\nROS2 itself is a binary program installed on your operating system, much the same as Firefox, Thunderbird or Octave. This is the program where all of the actual computation happens, and it is colloquially known as the ROS2-Core. It provides interfaces to other components on your computer, to perform actions.\nThe interface that ROS2 itself, the binary that we would install on our computer, provides however is not easy to use! The goal when designing it, was to enable fast, efficient and scalable processes, not to enhance programmer experience. Also, the way one would interact with this, does not follow the order of logical software development for robotics. It is in many ways a deep API, that provides a lot of functionality with few interfaces.\nBeyond the scope of this tutorial series, if you are interested in some interesting notes on how API\u0026rsquo;s in software could (should?) be designed, see this excellent talk on the topic. This is not in any way related to robotics, and is not required for this course however, and should be treated as further reading.\nTo enable us to write application code, i.e. nodes, packages and other structures within ROS2 in a way that makes sense to human robotics programmers, the ROS2 project provides client libraries. These libraries provide us with an abstraction layer to the \u0026ldquo;real\u0026rdquo; ROS2 system, that makes definitions of features easier. In these client libraries, we can find functions to create, start and stop nodes, to send information between nodes, to set parameters and much more. The client library internally translates these requirements into API calls for the actual ROS2 programm, that is running on our computer. The avaliability of this client library also determines if we can write ROS2 code in a particular programming language.\nIn general all clinet libraries contain the string rcl somewhere in their name, this stands for Ros Client Library. Two core client libraries that we will use are called rclcpp for C++ and rclpy for use with the python programming language. With these two being the most widley used client libraries, there are however ROS2 client libraries for a wide range of programming languages, for example rclc for C, rclrs for Rust and even rclnodejs for interaction with Node.js systems.\nAnother great advantage of the client library system is that we can mix and match programming languages within the same ROS2 project! For example, we can write our high level code controlling overall behaviour of the robot in python using rclpy as it is easier to develop and interate on, and use C++ with rclcpp to develop the performance sensitive parts of the real time control loops for our motors. At the core of our system is the ROS2 core, and the interface that defines how we talk to said core, is implemented in both programming languages, so we can talk to the same core in the same project at the same time.\nSo, in order to tell the core ROS2 installation on our computer what to do, we use the ROS2 client libraries to specify our application level code, i.e. nodes. If you are are looking for documentation on ROS2, you are most likley really looking for documentation on one of the ROS2 client libraries.\nWhat is a node? To make use of a client library and implement a ROS2 feature, let us familiarize ourself with the concept of a node first. Remember that in the introduction, we talked about splitting the project up into several different components, much the same way as the mechanical robot is made up of different parts, i.e. motors, gearboxes, batteries, etc. Every single process in a robot, we will put in a node!\nA node in ROS2 is a fundamental element, that serves a single modular purpose and implements a specific process. A ull robotic system, e.g. the whoel software that is controlling our exoskeleton, is comprised of many nodes that are working together. A node is a self contained process, and is also executed as one (more on that later!).\nBuilding a ROS2 node in Python We now want to apply this concept to practice, and make a functioning ROS2 node. As it is easier to read and follow for the most part, we will first explain the concept on the example of a ROS2 python node using the rclpy client library.\nFirst we have to create a new file where the node will live. It is good practice to create a separate file for each node that you are developing. To make sure that the build process runs smoothly, its also important that the nodes are created within the folder of a package that is named just like the package itself. You have to create a ROS2 node inside of a package, otherwise the build process will not work correctly and your node is unusable. In the case of this example, we will create a new node inside the practice project we have created for the first part of this tutorial, dealing with packages. Open up the same docker container and navigate to the package ros2-sample-package-python.\ncd ros2-sample-package-python Once inside, navigate to the folder ros2-sample-package-python by executing the same command again. You should now be inside the folder with the same name as the package. In here, you can create a new file using the touch utility. If you have the VScode instance connected, you can also use the new file button in te code editor to create a new file with the name sample_node.py.\ntouch sample_node.py Now open up the new file with the VScode code editor, or Vim if you prefer a terminal based approach. This is the file where we will create a new node in. The new node will have the same name as the file, however this is not strictly required and only best practice to do so. Initially we want to import the ROS2 client library for use with python, as we are in a python package.\nimport rclpy To make our code more legible and to prevent overly long function names, we want to import Node seperatly from the rclpy library as well\nfrom rclpy.node import Node We have now imported all prerequisites that are needed to build a ROS2 node. The Node object we imported is a class element, that we will use to create another instance of that class which will house the code that makes our node. Create a new instance of this in the code, by adding this to the file\nclass SampleNode(Node): Every ROS2 node requires an __init__ function, to provide functionality and become executable. This function defines the initialisation of the node and specifys some information that is required for the ROS2 core to allow the node to be useful. This __init__ function consists of several lines of code.\ndef __init__(self): super().__init__(\u0026#39;sample_node\u0026#39;) With super().__init__('sample_node') we have defined the name of the function to the rest of the ROS2 ecosystem. In theory you can add any name you want here, it would however create confusion and it\u0026rsquo;s therefore best practice to keep this the same as the file name. Additionally, the __init__ function does very much the same as any other python class. You can declare attributes of the class, i.e. variables by doing self.someVariable. There are a few other ROS2 features that will have to be declared in the __init__ function, which we will discuss later. As our code is not doing much at the moment, lets add a print statement to the __init__ function that we can see when executing the Node later. Your overall code should now look like this:\nimport rclpy from rclpy import Node class SampleNode(Node): def __init__(self): super().__init__(\u0026#39;sample_node\u0026#39;) print(\u0026#34;This node works!\u0026#34;) In doing so, you have just created a ROS2 node. Congratulations! As of now tho, we can not run the Node as there is no code that executes it. We add this, usually in the same file, by building a main function. This also applies to out python files, even though main functions are usually used in C++ projects. The structure of such a main function is quite standardized, and looks similar across many different nodes.\nFirst we dont want our function to accept any arguments for now, however it\u0026rsquo;s best to explicitly type this, to prevent problems. Then we have to initialize the rclpy connection by calling rclpy.init(). ROS2 considers the file that we are in a so called context, calling rclpy.init() initializes ROS2 for the first time in this context and connects the file with ROS2.\ndef main(args=None): rclpy.init(args=args) Next we have to create an instance of the class that is our node, and that we have defined in the same file above. To do so, we use the following code\nsample_node = SampleNode() Next stop is starting the ROS2 node. This happens using an executor, and there are several options on how to do this. For now, we will not go into detail here, just know that spin starts a ROS2 node, and make it execute indefinitly unless we either interrupt it manually or the garbage collector picks up the object when it is no longer in use, i.e. the whole ROS2 system has shut down. To make the node interruptable manually, we add a try execpt structure to listen for a KeyboardInterrupt. Whenever the KeyboardInterrupt is registered, we will call the destroy_node() method on the instance of the node to destroy the node. Afterwards we can close the ROS2 context, as no more actions are performed. This helps keep ROS2 clean and working properly. The whole main function should look like this after implementing the changes:\ndef main(args=None): rclpy.init(args=args) try: sample_node = SampleNode() rclpy.spin(sample_node) except KeyboardInterrupt: pass finally: sample_node.destroy_node() rclpy.shutdown() Now your ROS2 sample node is runnable and can be executed! However, there is currently no way for ROS2 to discover the node or to understand our keyboard inputs that this node is to be run. Also, we have used rclpy in this code, and have to specify this as a dependency of the package where the node is contained in. To add these, navigate back to the package root directory where you will find package.xml and setup.py.\nWithin package.xml we will have to note rclpy as a dependency of the package, do this by adding an exec_depend tag into the file, which should look something like this afterwards. While we are at it, also change the version, description and maintainer tags to fit with a name and a sample email.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;?xml-model href=\u0026#34;http://download.ros.org/schema/package_format3.xsd\u0026#34; schematypens=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34;?\u0026gt; \u0026lt;package format=\u0026#34;3\u0026#34;\u0026gt; \u0026lt;name\u0026gt;ros2-sample-package-python\u0026lt;/name\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;description\u0026gt;This is some description\u0026lt;/description\u0026gt; \u0026lt;maintainer email=\u0026#34;maintainer@someorg.com\u0026#34;\u0026gt;Maintainer Name\u0026lt;/maintainer\u0026gt; \u0026lt;license\u0026gt;Apache-2.0\u0026lt;/license\u0026gt; \u0026lt;test_depend\u0026gt;ament_copyright\u0026lt;/test_depend\u0026gt; \u0026lt;test_depend\u0026gt;ament_flake8\u0026lt;/test_depend\u0026gt; \u0026lt;test_depend\u0026gt;ament_pep257\u0026lt;/test_depend\u0026gt; \u0026lt;test_depend\u0026gt;python3-pytest\u0026lt;/test_depend\u0026gt; \u0026lt;exec_depend\u0026gt;rclpy\u0026lt;/exec_depend\u0026gt; \u0026lt;export\u0026gt; \u0026lt;build_type\u0026gt;ament_python\u0026lt;/build_type\u0026gt; \u0026lt;/export\u0026gt; \u0026lt;/package\u0026gt; We have to define an entry point into the node, that specify to the ROS2 command line tools where a command should execute a node. To do this, open up the setup.py file. Here you find the section entry_points. What is mean twith entry points, is the shortcode that you call using the ROS2 CLI to execute that node. After building, which is described in the next chapter, you will be able to call the ROS2 command line interface with something like ros2 run package entry_point, specifying what entry_point should be is the purpose of this file. To make a testrun possible add this to the setup.py.\nentry_points={ \u0026#39;console_scripts\u0026#39;: [ \u0026#39;test_our_node = ros2-sample-package-python.sample_node:main\u0026#39;, ], }, By doing this we specify the entry point test_our_node, this means we will be able to call ros2 run packageNameHere test_our_node after building this package. The line is always structured in the same way, first we define the entry_point denominator, which must be unique within that package. Then we write the package name, and with a dot after that the file name in which we defined our node. With \u0026lsquo;:\u0026rsquo; we seperate that file name from the name of the function that we desginted to run ou node, which will most often be main but it could be any other function in which we call rclpy.init(). If we were to change the line to 'nodetesting = ros2-sample-package-python.sample_node:main' the node would be launched with the commadn ros2 run packageNameHere nodetesting.\nNow we are done with defining the node. before we can execute it however, we will have to build the package that the node is contained in and set our workspace up for executing it. This will be handled in the next tutorial.\n"
},
{
	"uri": "http://localhost:1313/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "An Introduction to ROS2 Welcome to the RISE \u0026ldquo;An Introduction to ROS2\u0026rdquo; crash course!\nThe goal of this website is to provide notes and references for people interested in developing code within the ROS2 framework for use on the RISE exoskeleton. The world of ROS2 and robotic programming as a whole is quite vast, and this introduction is not attempting to introduce you to every nook and cranny of it. This is - hopefully not literally - a crash course, a set of notes and tasks that will help you get up to speed with writing ROS2 based code.\nThere are several parts of the ROS2 framework that we dont use on the exoskeleton for various reasons. As a result, those will not be covered here, or at most just quickly glossed over. Some parts of the framework are of particular importance, and will therefore be looked on with greater attention to detail. If you want to learn more about the ROS2 framework as a whole, there are lots of resources you can choose from, that take a much more holistic approach to ROS2 and robotic programming.\nWe don\u0026rsquo;t assume any prerequisites in robotic programming, or any of the tools named in this tutorial - even though it certainly helps! This tutorial is structured so that you can skip chapters and parts that deal with information you already know. Every chapter is presented in four different ways:\nThis website combines notes, graphs, images and code snippets. Wherever possible we make references to the code used on the current exoskeleton.\nThe presentation slides avaliable for download on the top of each chapter page. These are the slides used during the introduction workshop at the beginning of each semester.\nThe video recordings of these presentations, as well as some other topics that are worth it to show in greater detail.\nSeveral code examples and notebooks for trying out the content by yourself on your own machine. All of these can be found in this repository.\nAs you will learn, ROS has been under development for a while. Right now, there are many Distributions of ROS that each are named after some species of turtle (Humble Hawksbill, Jazzy Jalisco and so on). However a few years back, the ROS project released a breaking change that remodelled a lot of the underlying architecture, this version is now formally called ROS2 and no longer just ROS, and it\u0026rsquo;s what we are using in this project. For the sake of simplicity we will refer to these ROS2 versions as ROS, but be warned that tutorials from the original ROS, are not fully translatable to how modern ROS(2) works. So, if you are diving deeper into this topic and are trying to find further readings, make sure that the material is about ROS2 (and ideally the two most recent LTS versions \u0026ldquo;Humble\u0026rdquo; and \u0026ldquo;Jazzy\u0026rdquo;) and not the original ROS.\nYou are welcome to only take a look at some of these, or watch all of them. Not for every task in the semester there is a need to know every bit of what\u0026rsquo;s explained in this tutorial, but having a general grasp on how things work is quite useful.\n"
},
{
	"uri": "http://localhost:1313/ros2-ecosystem/",
	"title": "The ROS2 Ecosystem",
	"tags": [],
	"description": "",
	"content": "Chapter V The ROS2 Ecosystem This chapters deals with the ecosystem surrounding RO2.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/ros2-build-system/",
	"title": "The colcon build tool",
	"tags": [],
	"description": "",
	"content": "Within ROS2 we have to use the build system, to make the code that we wrote into our nodes usable and executable for the ROS2 core. Back in the day, in the times of ROS1, the build system for these purposes was called catkin, which is a heavily customized set of CMake based routines. This build system had a couple of drawbacks and problems that pushed the maintainers of the ROS project towards developing a new system for the release of ROS2. This new system is made up of two parts, the ament build system and the tooling that the developer uses to talk to this build system from the command line: colcon. The type of ament that is used depends on the type of package that is to be build. When we defined a package in the last chapter, you may remember that is twas important to specify this build system when setting up the package in the package.xml file.\n\u0026lt;export\u0026gt; \u0026lt;build_type\u0026gt;ament_python\u0026lt;/build_type\u0026gt; \u0026lt;/export\u0026gt; Ament itself is quite complicated to get to know, and not relevant for everyday development of robotic software - unless you want to dive deep into performance optimization on the compiler level. Thats why we wont make an effort to learn the details about this build system and instead assume it to work like the developers intended: as a build system for different modules ()\u0026ldquo;packages\u0026rdquo;) together in one workspace that have to run on a robotic device. The more important part when it comes to actually developing software with ROS is the colcon build tool, i.e. the command line application that we use to interact with ament.\nUnderstanding colcon Colcon is a build tool, it does not do the building itself but instructs ament how to do so. Technically, no one is stopping you from calling the ament build system directly, they are also installed on your computer if you installed ROS2 correctly. However, calling the build system directly is usually only an added hassle that does not provide much advantages to the user.\nColcon generally works on the principle of a \u0026ldquo;workspace\u0026rdquo; based build system, i.e. you dont have to manually type out all the files that you watnt o build, and the specific oder and dependencies that they are to be build. Instead the workspace, i.e. a directory on your computer has to be structured ina specific way and colcon does the rest. The structure that is required for colcon is exactly the structure that we have set up in the previous chapters around packages, nodes and package.xml files. When you use colcon, it will search through all subdirectoys below the level where the command is invoked for packages. To make everything more legible and easier to understand its best to put all of your packages into the src subdirectory.\nOnly those folder around a package.xml file, colcon understands to be a package, and is able to build. Missing this file therefore results in the tool just skipping the set of files and not building them.\nUsually we often consider building to be closely linked to compiling something, however we also have to build packages written in interpreted languages such as Python. This obviously has nothing to do with compiling, but more with linking the intepreter to the location of the code files that it has to run when they are called up.\nUsing colcon Actually using colcon is quite easy! There is no need to perform an installation, as the package is installed together with the regular ROS2 installation. Also, as for the purposes of this course we will only talk about the basics of colcon, digging deeper is usually only required for configuring custom build systems.\nLet\u0026rsquo;s build the package that we created during the last chapter of this tutorial series! First start the Docker container and attach your VSCode session to it. Then open up a Terminal that is linked to the container. In case you have questions regarding how to do this, see the Installation chapter of this series. Inside of this tutorial, navigate to the workspace, we called this workspace ros2-node-test-workspace. You should be able to call ls and see something similar:\nroot@2ffb27508d09:~/ros2course/ch2-1-creating-nodes/ros2-node-test-workspace# ls -l total 4 drwxr-xr-x 5 root root 4096 Oct 1 09:59 src This place, where we can see the src directory, is called the workspace root, not because we are the user root, but because it\u0026rsquo;s the root point of the workspace. If we want to build all packages in the subdirectiy src and not have any other special requirements that differ from the defaults we can simply call the build command.\ncolcon build This will result in the following output.\nStarting \u0026gt;\u0026gt;\u0026gt; ros2-sample-package-cmake Starting \u0026gt;\u0026gt;\u0026gt; ros2-sample-package-python Finished \u0026lt;\u0026lt;\u0026lt; ros2-sample-package-python [0.92s] Finished \u0026lt;\u0026lt;\u0026lt; ros2-sample-package-cmake [0.96s] Summary: 2 packages finished [1.09s] You have now build the packages that are located in the src folder! IF you run ls- l again, you will however see that there are new directorys in the workspace root.\nlog Within this folder you will find the logs that concern the build process. These are not the logs that come up while you run the programm, those are by default routed to the terminal and have to be stored seperatly if you wish to do so. Inside the folder is another directory that will be called build_[Date and time when building]. Inside this package we have the detailed logs of the build process, where you can investigate a potential error that would come up during building. If you are interested, this is also an interesting place to understand the anatomy of the build system, as the CMake interface is quite exposed here. The unsorted but complete log of the build process can be found in the file logger_all.log.\nbuild When colcon is building a package, it keeps some build artifacts when finishing to make subsequent build runs faster. The build directory is where these are stored. They are seperated byt the name of the package and are overwritten automatically in the next build if something changes. It is best to not tamper with these artifacts, as this could break the results of the coming builds. Also, in case your build seems to be stuck on a problem you are sure you\u0026rsquo;ve fixed, it is useful to delete this directory. colcon will recreate it the next time you run colcon build, and no old artifacts that are erroneously kept can corrupt your build result.\ninstall This is the main result of the colcon build process, as it stores the result and the scripts that you use to source these results. Inside this folder you will find seperate directorys for all the packages that you\u0026rsquo;ve defined in your workspace, where the resulting files are kept. If you compare the python package to the cmake package, you will see the difference in structure and amount of packages. Next to the directorys that hosue the names of the packages, youll also find several scripts and shell files. These are required so that you can source the result of the build process to your current shell for execution. Currently colcon supports mainly the bash and zsh shell on Linux and MacOD, and powershell on Windows. To source the result of the installation, wait for the build process to finish and then, from the root of your workspace, invoke the following command (for bash, use .zsh for the zsh shell).\nsource install/setup.sh Especially if you are making changes to the ROS2 codebase and aim to execute the code on the robot, make sure to double check the results of your build process,a nd wether or not you are sourcing the correct setup.sh file\nThis is really important. If you dont call this command, the changes you made to the ROS2 code will not apply and you cant use them. Now the results of your code have been built and are ready to be executed on the robot. Before doing so, we will however take a look at how the two nodes we just build, can talk to another in the next chapter.\n"
},
{
	"uri": "http://localhost:1313/ros2-concepts/ros2-communication-nodes/",
	"title": "Communication between nodes",
	"tags": [],
	"description": "",
	"content": "To make sure that data that is gathered, for example, on the camera is being transmitted to the actuator so that the robot would physically react to an obstacle that is in front of him, ROS2 provides a communication system so that different nodes can communicate with another. This communication system, also sometimes referred to as a data-distribution layer, will send information between different processes at runtime. The theory and software that underpins this functionality is not unique to ROS2 and is used extensively throughout other software projects in the industry.\nTheory and structure of remote procedure calling The goal of the ROS2 communication framework is to allow two nodes, that run at the same time to exchange information between them. Traditionally, when we think about programms, they are encapsulated from the rest of the operating system, running subsequently and are being executed after one another. However, as we discussed before, in robotics programming we structure our software into several small nodes that all run at the same time, similar to the microservice architecture employed by large scale software systems.\nThe tool we use to make this work is called A DDS, ie.e. a Data Distribution Layer. We can think of this as a middleware, not quite on the level of the operating system but also not application level code. This middleware is not exclusive to ROS2, instead its being used all over the software landscape in many projects, a lot of them having nothing to do with robotics. A DDS has to do three main different types of work:\nDiscovery: Discovering other instances of a DDS to be able initialize a connection Data exchange: Sending and receiving messages Quality of service (QoS): Controlling the reliability and latency of messages to meet deadline in cases where this is required. Most DDS frameworks are built on top of the principle of the publish subscribe architecture. The \u0026ldquo;source\u0026rdquo; of an information, i.e. some node for example, publishes the information that is to be transmitted on some channel. The recieving party, i.e. some other node is then subscribing to that communication channel to get any bit of information that is send. We can think of different structures, there may be only one publisher and many subscribers, a type of one-to-many relationship, where no bidirectional communication exists, so the publisher is not a subscriber at the same time. This structure would be called \u0026ldquo;Broadcast\u0026rdquo;. There may also be bilateral communication channels where there are only two nodes connected, and each of them in publisher and subscriber at the same time.\nWe also refer to the implementation of such communication systems as remote procedure calling\nThe ROS2-DDS We mentioned before that there are several implementations of a DDS. ROS2 gives us the opportunity to select a DDS among different options, with each of the different options suiting different needs. By default ROS2 supports Eclipse Cyclone DDS, eProsima Fast DDS and GurumNetworks GurumDDS. By default, unless specified otherwise, Fast DDS is used, so that\u0026rsquo;s what we are going to talk about in this tutorial. With the exception of more specialized applications Fast DDS is almost always sufficient for most usecases, and there is little need to adapt. One notable exception to that however are real time compliant ROS2 systems. If real time compliance is a hard requirement, ROS2 has to be rebuilt from source with the Connext DDS, which is not included by default. Using Connext for other applications is not advisable, as the way it is to be run and used differs quite a bit from the other DDS systems, due to the inherent real time specifications.\nThe communication with the DDS happens via the ROS2 client libraries, so it is very well possible to abstract away the details of the data distribution layer when building application level software. From the developer the interface of the data channel has to be defined and, most importantly, the type of data that is to be transmitted that has to be written down in a defined message file.\nDefining data that is to be transmitted When we want to transmit data we first have to define the shape and size of the dataset that we want to transmit. There are some defaults that are provided by ROS2 and dont require any more effort. These include the following data types:\nName of type C++ data type Python data type DDS data type bool bool builtins.bool boolean byte uint8_t builtins.bytes* octet char char builtins.str* char float32 float builtins.float* float float64 double builtins.float* double int8 int8_t builtins.int* octet uint8 uint8_t builtins.int* octet int16 int16_t builtins.int* short uint16 uint16_t builtins.int* unsigned short int32 int32_t builtins.int* long uint32 uint32_t builtins.int* unsigned long int64 int64_t builtins.int* long long uint64 uint64_t builtins.int* unsigned long long string std::string builtins.str string wstring std::u16string builtins.str wstring It is also possible to combine these into arrays using the following avaliable structures\nName of type C++ data type Python data type DDS data type static array std::array\u0026lt;T, N\u0026gt; builtins.list* T[N] unbounded dynamic array std::vector builtins.list sequence bounded dynamic array custom_class\u0026lt;T, N\u0026gt; builtins.list* sequence\u0026lt;T, N\u0026gt; bounded string std::string builtins.str* string Sometimes these datatypes are not enough and a dataset containing more than one value is required that can not simply be combined using one of the aforementioned structures. In this case we have to make a custom data structure that can be a combination of any of the previous datatypes and is sent in one go, therefore we dont have to wait for some parts of the message to arrive. We will now define an example of such a message definition.\nDefining custom messages should, by convention, happen in a seperate package whose contents are then imported into other packages. It is important to know that custom messages can only be defined in ament_cmake packages. As the packes themself dont contain any application level code, this has few consequences on the development experience. Obviosuly its also possible to import the message defined in a C++ package in a python package. To create such a package move back into your code editor, and open up the directory ch2-2-defining-messages that is present in the repository you\u0026rsquo;ve forked.\nOnce inside that folder we can create new package on the ament_cmake build system with the name \u0026ldquo;example_messages\u0026rdquo;.\nros2 pkg create --build-type ament_cmake example_messages Navigate inside that package. Here we will define the different message types. In general we have to distinguish between two different types of messages, the .msg pure message and the .srv message. Both serve the purpose of transferring data but are slightly different. Therefore we want to define two directorys inside the package, msg and srv isnide the src directory.\ncd src mkdir msg srv All definitions of data transfer objects are made in files with either the ending .msg for messages and .srv for service messages. Essentially, .msg files are for unidirectional data transfer, where one node sends data and does not care about neither the recipient nor the response. The .srv files are for bidirectional data exchange between two nodes. We will talk about this topic in more detail in the following paragraf after finising the definition of the message package.\nWe will create a simple .msg example, that will allow a node to transmit two int64 type data points. Navigate inside the .msg directory and create a new file called ExampleNumbers.msg. Now open up this file and add the following lines:\nint64 ExampleNumberOne int64 ExampleNumberTwo In doing so we defined the message type ExampleNumbers that we can import into other nodes in the future. This message type now has two properties ExampleNumberOne and ExampleNumberTwo, both of them of type int64. Using this message we can now broadcast two 64bit Integers! Now we want to also create a service message file. Move out of the msg directory, and open the srv directory. Once there, create a new file called ExchangeNumber.srv. As mentioned before, these messages can implement bidirectional communication, meaning that the node that initiates the transmission will also recieve a response. This behaviour is directly mapped to the structure of the file structure of the message. Create this in ExchangeNumber.srv:\nint64 NumberToSend --- int64 NumberToRecieve Here we will transmit the NumberToSend property to some other node, and this node will return the NumberToRecieve property after doing some computation within the node.\nTo be able to use these newly defined message types within other packages, we need to perform some housekeeping and add boilerplate code to the package definition. We have to add some additional build instructions to thr CMakeLists.txt file.\nfind_package(rosidl_default_generators REQUIRED) rosidl_generate_interfaces(${PROJECT_NAME} \u0026#34;msg/ExampleNumbers.msg\u0026#34; \u0026#34;srv/ExchangeNumber.srv\u0026#34; ) Additionally there have to be edits to the package.xml file, to make sure that the rosidl_default_generators component of ROS2 is loaded properly, as it is required for building the message package.\n\u0026lt;build_depend\u0026gt;rosidl_default_generators\u0026lt;/build_depend\u0026gt; \u0026lt;exec_depend\u0026gt;rosidl_default_runtime\u0026lt;/exec_depend\u0026gt; \u0026lt;member_of_group\u0026gt;rosidl_interface_packages\u0026lt;/member_of_group\u0026gt; Now the package is ready to be built. As we may use this later on in a large project, we will only built this package. To do this using colcon execute the following command at the root of the project, e.g. ch2-2-defining-messages.\ncolcon build --packages-select example_messages This sums up the build process of a simple package that contains a .srv and a .msg file. We will now take a look at how these can be used, and what type of data exchange can be performed using these.\nTypes of communication channels There are different ways how ROS2 Nodes can communicate with another. In general, this tutorial only talks about the communication inbetween nodes, within one node regular processes of Python or C++ can be used, e.g. encapsulating functionality in functions, etc. We may either broadcast information or transmit it. In ROS2 broadcasting happens using a Topic, transmitting information is done via Actions or Services.\nTopics Topics can be compared to a radio frequency in FM/AM radio. There is no information available to the sender that specifies the number of receivers or if there even are any. There is also no direct response, the reciever may choose to answer but might also refrain from doing so. Multiple parties can speak on the same topic, but not at the same time. Topics are best used for continous data streams and are often periodically updated. For example, there might be a temperature sensor in our battery that is transmitting the current temperature every ten seconds. There can both be many senders on the same topics as there can be many recievers. There may also be many senders but only one receiver.\nActions Actions are designed for longer-running tasks that may require feedback, monitoring, or preemption. Unlike services, actions allow for continuous communication between the client and server while a goal is being executed, enabling progress updates and cancellation if needed. They are suitable for processes that take significant time or involve multiple steps, such as computing a new movement strategy or navigating to a waypoint. Actions provide structured feedback and result messages, making them ideal for tasks that must be interruptible and observable throughout their execution.\nServices Services are best used for quick, one-time interactions that complete rapidly and provide an immediate response. They operate in a request–response manner, where a client sends a request and waits for a server to process and return a result. Services are ideal for short, well-defined tasks such as retrieving system information, setting parameters, or performing brief computations. They should not be used for long-running operations or processes that require continuous feedback, as they are designed for fast, blocking calls that complete in a single exchange.\nMaking two nodes talk to one another We will now try to get started with making two ros2 nodes talk to each other. To do so, open up the tutorial and navigate to the folder ch2-3-make-the-nodes-talk. Let us investigate it\u0026rsquo;s contents.\nInside the src folder can see four packages, listener_node, talker_node, broadcast_node and the msg_package. They are all defined as packages, so going further remember that the location where you can see the src directory, this is the root of the project and the place from which we want to execute the build commands.\nIf you navigate to the msg_package, you can see that this is very similar to the message package we created in the last section. It contains two declerations of interfaces, a .msg file and a .srv file. Inside Broadcast.msg you can see that we will broadcast a simple single integer value.\nint64 num The service decleration Transmit.srv is a bit more complex, as it contains both a request and a response part.\nint64 value int64 value2 int64 value3 --- int64 result These are the two types of information that we will send, once the Broadcast.msg as part of a topic and once the Transmit.srv as part of a service. Now take a look at the broadcast package, as this will demonstrate the implementation of a topic based communication channel.\nUsing topics Inside the broadcast_node you will find a package that is also called broadcast_node. Inside there are two files, one of them being called broadcast.py. Open up this file. This is an example of a simeple ROS2 naodes that implements a topic publisher. The communication that originates from this node is unidirectional, meaning that there is no response expected from any other node and the topic is simply broadcasted out. It is very well possible that a topic is broadcasted but no other node is listening to it.\nIn the beginnign we are importing the rclpy library, that contains the ROS2 client library for Python. Additionally we are importing the Node class, as we will create a node that will broadcast information. Finally we are importing the Broadcast message type from the msg_package that we defined earlier.\nimport rclpy from rclpy.node import Node from msg_package.msg import Broadcast The node itself, as explained before, is defined as a class that inherits from the Node class. In the constructor of this class we are initializing the node with the name publish_information. Up until this point, this is a regular implementation of a ROS2 node. In the next line we are defining a publisher. It is important to note that publishers and subscribers are referring to topics and not to services.\nself.publisher_ = self.create_publisher(Broadcast, \u0026#39;topic\u0026#39;, 10) The publisher is defined as an attribute of the node itself and consists of three properties. First we define the type of message that we want to send over the topic. This is what we defined previously with the custom defined message within the package msg_package. Next, we define the name of the topic, in this case it is simply named topic, but we are free to choose almost any other name. Finally, we define the size of the message queue. This is important as messages may be sent faster than they are being received. In most cases however, this is not strictly required and we will not go into more detail in the basic chapter of this tutorial series.\nIn the following line we are introducing another concept od ROS2, the timer! A timer executes a certain function at a defined interval. In this case we are defining a timer that will execute the timer_callback function every half second, i.e. every 500 milliseconds. After this interval the methiod timer_callback will be executed.\ntimer_period = 0.5 self.timer = self.create_timer(timer_period, self.timer_callback) Afterwwards we initialize the counter property of the node i as 0. This will be used to increment the value that is being broadcasted. The relevant properties of the publishing procedure happen within the timer_callback function. In here we define the message to be of type Broadcast, the message type we defined earlier. Then we set the property num of the message to be equal to the counter property i. After this we log the information that is being broadcasted, so that we can see it in the terminal. Finally we publish the message using the publisher that we defined earlier.\nmsg = Broadcast() msg.num = self.i self.publisher_.publish(msg) self.get_logger().info(\u0026#39;Publishing: \u0026#34;%s\u0026#34;\u0026#39; % msg.data) self.i += 1 The main function is quite similar to the ones we have set up before, we initialize rclpy, create an instance of the ExamplePublisher node and spin it up to have the code working. Finally we destroy the node and shutdown rclpy after we are done.\nrclpy.init(args=args) minimal_publisher = ExamplePublisher() rclpy.spin(minimal_publisher) minimal_publisher.destroy_node() rclpy.shutdown() Using services We can also transmit information using services. The advantages of services is, that they allow bidirectional communication, meaning that the node that is sending the information can also recieve a response from the node that is processing the information. To demonstrate this, we will take a look at the talker_node package. Inside this package there is a file called service_server.py. Open up this package directory, you will find a file inside the src subdirectory called server_node.cpp. This file contains the node that is serving new service messages.\n#include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;msg_package/srv/transmit.hpp\u0026#34; #include \u0026lt;memory\u0026gt; #include \u0026lt;inttypes.h\u0026gt; In the beginnign we import the usual packages, in this case the rclcpp package for C++ and the custom defined service message from the msg_package package. The memory and inittypes packages are standard C++ packages that are required for memory managment and integer type definitions. In case we define our functiosn differently, we could get around using them.\nvoid handle_transmit( const std::shared_ptr\u0026lt;msg_package::srv::Transmit::Request\u0026gt; request, std::shared_ptr\u0026lt;msg_package::srv::Transmit::Response\u0026gt; response) { response-\u0026gt;result = request-\u0026gt;value + request-\u0026gt;value2 + request-\u0026gt;value3; RCLCPP_INFO( rclcpp::get_logger(\u0026#34;transmit_server\u0026#34;), \u0026#34;Incoming request:\\n value: %\u0026#34; PRId64 \u0026#34; value2: %\u0026#34; PRId64 \u0026#34; value3: %\u0026#34; PRId64, request-\u0026gt;value, request-\u0026gt;value2, request-\u0026gt;value3); RCLCPP_INFO( rclcpp::get_logger(\u0026#34;transmit_server\u0026#34;), \u0026#34;sending back response: [%\u0026#34; PRId64 \u0026#34;]\u0026#34;, response-\u0026gt;result); } This is the initial function that will handle incoming service requests. It takes two arguments, the request and the response. The request is a shared pointer to the request part of the service message, the response is a shared pointer to the response part of the service message. Inside this function we are simply summing up the three values that are being sent as part of the request and setting this as the result property of the response. Additionally we are logging both the incoming request as well as the outgoing response to the terminal.\nint main(int argc, char **argv) { rclcpp::init(argc, argv); auto node = rclcpp::Node::make_shared(\u0026#34;transmit_server\u0026#34;); auto service = node-\u0026gt;create_service\u0026lt;msg_package::srv::Transmit\u0026gt;(\u0026#34;transmit\u0026#34;, \u0026amp;handle_transmit); RCLCPP_INFO(rclcpp::get_logger(\u0026#34;transmit_server\u0026#34;), \u0026#34;Ready to sum three int64s.\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); return 0; } The main function is similar to the ones we have seen before. We initialize rclcpp, create a node with the name transmit_server and then create a service on that node. The service is of type Transmit, the custom defined service message we created earlier. The name of the service is transmit and the function that will handle incoming requests is handle_transmit, the function we defined previously. After logging that the server is ready, we spin the node to have it process incoming requests. Finally we shutdown rclcpp when we are done.\nAs we are now defining a service, we require a secondary node that will send requests to this service and process the responses. This is done in the service_client.py file within the listener_node package. Open up the package. In there you will notice two files, service_client.py and listener.py. We will focus on the service_client.py file for now, as this is the node that will send requests to the service server we defined earlier.\n#!/usr/bin/env python3 import sys import rclpy from rclpy.node import Node from msg_package.srv import Transmit Here we are importing the required packages, similar to what we have done before. The only new import is the sys package, which is a standard Python package that allows us to access command line arguments.\nclass TransmitClient(Node): def __init__(self): super().__init__(\u0026#39;transmit_client\u0026#39;) self.cli = self.create_client(Transmit, \u0026#39;transmit\u0026#39;) while not self.cli.wait_for_service(timeout_sec=1.0): self.get_logger().info(\u0026#39;service not available, waiting...\u0026#39;) self.req = Transmit.Request() def send_request(self, a, b, c): self.req.value = int(a) self.req.value2 = int(b) self.req.value3 = int(c) return self.cli.call_async(self.req) This is the definition of the TransmitClient node. In the constructor we initialize the node with the name transmit_client. Then we create a client that will connect to the service named transmit, which is the service we defined in the service server node earlier. After this we wait for the service to become available, as it may take some time for the server to start up. Finally we create a request object that will be used to send requests to the server.\ndef main(): rclpy.init() node = TransmitClient() try: for i in range(5): a, b, c = i, i + 1, i + 2 future = node.send_request(a, b, c) rclpy.spin_until_future_complete(node, future) if future.result() is not None: node.get_logger().info(f\u0026#39;[{i+1}] result: {future.result().result}\u0026#39;) else: node.get_logger().error(\u0026#39;service call failed\u0026#39;) time.sleep(1.0) except KeyboardInterrupt: pass node.destroy_node() rclpy.shutdown() The main function is similar to what we have seen before. We initialize rclpy, check if the correct number of command line arguments are provided, and create an instance of the TransmitClient node. Then we send a request to the server using the command line arguments as values. We wait for the response using spin_until_future_complete. If we receive a result, we log it repeatedly to the terminal. Finally, we destroy the node and shutdown rclpy.\nLaunching the nodes Now we want to launch these nodes locally, to see how the information is transmitted between the different nodes. To do so, open up a terminal and navigate to the root of the project, e.g. ch2-3-make-the-nodes-talk. First, we will build all packages using colcon.\ncolcon build --symlink-install In case we have previously build the project already and made changes, its good practice to clean the build, install and log directories before building again.\nrm -rf build install log colcon build --symlink-install Then we fill first try out the topic based communication. Open up an additional terminal window. In both windows source the install setup file.\nsource install/setup.bash Now the build project is intialized and ready to go. In the first terminal window, we will launch the broadcast node that will publish information on a topic. To do so, execute the following command:\nros2 run broadcast_node broadcast Then, in the second tutorial, execute the listener node that will subscribe to the topic and receive the information.\nros2 run listener_node listener You should now see in the terminal window of the listener node that it is receiving the information that is being broadcasted by the broadcast node! Now let us try the same for the service node. Stop both processing by hitting CTRL+C in both terminal windows. Then, in the first terminal window, launch the listener node with the three number 1, 2 and 3.\nros2 run listener_node service_client 1 2 3 Then, in the second terminal window, launch the talker node that will serve the service requests.\nros2 run talker_node server_node You should now see in the terminal window of the service client that it is receiving the summed up result from the service server! Congratulations, you have successfully made two ROS2 nodes talk to each other using both topics and services!\n"
},
{
	"uri": "http://localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]